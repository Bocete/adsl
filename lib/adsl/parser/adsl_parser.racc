class ADSLParser
  prechigh
    left '==' '!='
    noassoc NOT
    left '<=>'
    left '<=' '=>'
    left and or
    left '.'
    right '='
  preclow
  token class extends inverseof action foreach flatforeach unflatforeach either or create delete if else subset oneof tryoneof allof invariant forall exists in isempty empty true false not and equal equiv implies unknown IDENT BASIC_TYPE JS
  start adslspec
rule
  adslspec: root_elems { return ASTSpec.new :lineno => lineno, :classes => val[0][0], :actions => val[0][1], :invariants => val[0][2] }
  
  root_elems: class_decl root_elems     { val[1][0].unshift val[0]; return val[1] }
            | action_decl root_elems    { val[1][1].unshift val[0]; return val[1] }
            | invariant_decl root_elems { val[1][2].unshift val[0]; return val[1] }
            |                           { return [[], [], []] }

  class_decl: class IDENT opt_parents '{' member_decls '}' 
                       { return ASTClass.new :lineno => val[0], :name => val[1], :parent_names => val[2],  :members => val[4] }

  opt_parents: extends IDENT more_parents { val[2].unshift val[1]; return val[2] }
             |                            { return [] }

  more_parents: more_parents ',' IDENT { val[0] << val[2]; return val[0] }
              |                        { return [] }

  member_decls: member_decls member_decl { val[0] << val[1]; return val[0] }
              |                          { return [] }

  member_decl: cardinality IDENT IDENT inverse_suffix { return ASTRelation.new :lineno => val[0][2], :cardinality => val[0].first(2), :to_class_name => val[1], :name => val[2], :inverse_of_name => val[3] }
             | BASIC_TYPE IDENT { return ASTBasicTypeField.new :lineno => val[0][1], :type_name => val[0][0], :name => val[1] }

  cardinality: card_number                  { return [val[0][0], val[0][0], val[0][1]] }
             | card_number '..' card_number { return [val[0][0], val[2][0], val[0][1]] }
             | card_number '+'              { return [val[0][0], 1.0/0.0, val[0][1]] }

  card_number: '0'    { return [0, lineno] }
             | '1'    { return [1, lineno] }

  inverse_suffix: inverseof IDENT { return val[1] }
                |                 { return nil }

  action_decl: action IDENT '(' action_args ')' block { return ASTAction.new(:lineno => val[0], :name => val[1], :arg_cardinalities => val[3][0], :arg_types => val[3][1], :arg_names => val[3][2], :block => val[5]) }

  action_args: additional_args cardinality IDENT IDENT { val[0][0] << val[1]; val[0][1] << val[2]; val[0][2] << val[3]; return val[0] }
             |                                         { return [[], [], []] }
             
  additional_args: additional_args cardinality IDENT IDENT ',' { val[0][0] << val[1]; val[0][1] << val[2]; val[0][2] << val[3]; return val[0] }
                 |                                             { return [[], [], []] }

  block: '{' statements '}' { return ASTBlock.new :lineno => val[0], :statements => val[1] }

  statements: statement statements { val[1].unshift val[0]; return val[1] }
            |                      { return [] }

  statement: expr                         { return ASTExprStmt.new :lineno => val[0].lineno, :expr => val[0] }
           | delete expr                  { return ASTDeleteObj.new :lineno => val[0], :objset => val[1] }
           | expr '.' IDENT '+=' expr {
               return ASTCreateTup.new :lineno => val[0].lineno, :objset1 => val[0], :rel_name => val[2], :objset2 => val[4]
             }
           | expr '.' IDENT '-=' expr {
               return ASTDeleteTup.new :lineno => val[0].lineno, :objset1 => val[0], :rel_name => val[2], :objset2 => val[4]
             }
           | expr '.' IDENT '=' expr {
               return ASTMemberSet.new :lineno => val[0].lineno, :objset => val[0], :member_name => val[2], :expr => val[4]
             }
           | foreach_stmt                   { return val[0] }
           | either block or eitherblocks   { val[3].unshift val[1]; return ASTEither.new :lineno => val[0], :blocks => val[3] }
           | if formula block optelse       { return ASTIf.new :lineno => val[0], :condition => val[1], :then_block => val[2], :else_block => val[3] }

  foreach_stmt: foreach IDENT ':' expr block {
               return ASTForEach.new :lineno => val[0], :var_name => val[1], :objset => val[3], :block => val[4]
             }
           | flatforeach IDENT ':' expr block {
               f = ASTForEach.new :lineno => val[0], :var_name => val[1], :objset => val[3], :block => val[4]
               f.force_flat(true)
               return f
             }
           | unflatforeach IDENT ':' expr block {
               f = ASTForEach.new :lineno => val[0], :var_name => val[1], :objset => val[3], :block => val[4]
               f.force_flat(false)
               return f
             }

  optelse: else block  { return val[1] }
         |             { return ASTBlock.new :statements => [] }
  
  eitherblocks: eitherblocks or block { val[0] << val[2]; return val[0] }
              | block                 { return [val[0]] }

  expr: IDENT                     { return ASTVariable.new :lineno => val[0].lineno, :var_name => val[0] }
      | IDENT '=' expr            { return ASTAssignment.new :lineno => val[0].lineno, :var_name => val[0], :expr => val[2] }
      | subset '(' expr ')'       { return ASTSubset.new :lineno => val[0], :objset => val[2] }
      | oneof '(' expr ')'        { return ASTOneOf.new :lineno => val[0], :objset => val[2] }
      | tryoneof '(' expr ')'     { return ASTTryOneOf.new :lineno => val[0], :objset => val[2] }
      | allof '(' IDENT ')'       { return ASTAllOf.new :lineno => val[0], :class_name => val[2] }
      | create '(' IDENT ')'      { return ASTCreateObjset.new :lineno => val[0], :class_name => val[2] }
      | create '(' expr '.' IDENT ')' {
          return ASTDereferenceCreate.new :lineno => val[0], :objset => val[2], :rel_name => val[4]
        }
      | expr '.' IDENT           { return ASTMemberAccess.new :lineno => val[0].lineno, :objset => val[0], :member_name => val[2] }
      | empty                    { return ASTEmptyObjset.new :lineno => val[0] }
      | '(' expr ')'             { return val[1] }
      | JS                       { return ASTJsExpr.new :lineno => val[:lineno], :js => val[:js] }

  invariant_decl: invariant formula           { return ASTInvariant.new :lineno => val[0], :name => nil, :formula => val[1] }
                | invariant IDENT ':' formula { return ASTInvariant.new :lineno => val[0], :name => val[1], :formula => val[3] }

  formula: forall '(' quantifier_parameters_with_commas ':' formula ')'
           { return ASTForAll.new :lineno => val[0], :vars => val[2], :subformula => val[4] }
         | exists '(' quantifier_parameters_with_commas optional_formula ')'
           { return ASTExists.new :lineno => val[0], :vars => val[2], :subformula => val[3] }
         | not formula
           { return ASTNot.new :lineno => val[0], :subformula => val[1] } =NOT
         | formula and formula
           { return ASTAnd.new :lineno => val[0].lineno, :subformulae => [val[0], val[2]] }
         | formula or formula
           { return ASTOr.new :lineno => val[0].lineno, :subformulae => [val[0], val[2]] }
         | formula '<=>' formula
           { return ASTEquiv.new :lineno => val[0].lineno, :subformulae => [val[0], val[2]] }
         | formula '=>' formula
           { return ASTImplies.new :lineno => val[0].lineno, :subformula1 => val[0], :subformula2 => val[2] }
         | formula '<=' formula
           { return ASTImplies.new :lineno => val[0].lineno, :subformula1 => val[2], :subformula2 => val[0] }
         | '(' formula ')' { return val[1] }
         | equiv '(' formula ',' formula additional_formulae ')'
           { return ASTEquiv.new :lineno => val[0], :subformulae => [val[2], val[4]] + val[5] }
         | implies '(' formula ',' formula ')'
           { return ASTImplies.new :lineno => val[0], :subformula1 => val[2], :subformula2 => val[4] }
         | expr '==' expr
           { return ASTEqual.new :lineno => val[0].lineno, :exprs => [val[0], val[2]] }
         | expr '!=' expr
           { return ASTNot.new(:lineno => val[0].lineno, :subformula => ASTEqual.new(:lineno => val[0].lineno, :exprs => [val[0], val[2]])) }
         | equal '(' expr ',' expr additional_exprs ')'
           { return ASTEqual.new :lineno => val[0], :exprs => [val[2], val[4]] + val[5] }
         | expr in expr          { return ASTIn.new :lineno => val[0].lineno, :objset1 => val[0], :objset2 => val[2] }
         | true                  { return ASTBoolean.new :lineno => val[0], :bool_value => true  }
         | false                 { return ASTBoolean.new :lineno => val[0], :bool_value => false }
         | '*'                   { return ASTBoolean.new :lineno => val[0], :bool_value => nil   }
         | isempty '(' expr ')'  { return ASTIsEmpty.new :lineno => val[0], :objset => val[2] }

  quantifier_parameters_with_commas: quantifier_parameters_with_commas ',' quantifier_parameter
            { val[0] << val[2]; return val[0] }
                                   | quantifier_parameter { return [val[0]] }

  quantifier_parameter: IDENT IDENT {
                          return [val[1], ASTAllOf.new(:lineno => val[0].lineno, :class_name => val[0]), val[0].lineno]
                        }
                      | IDENT in expr { return [val[0], val[2], val[0].lineno] }

  optional_formula: ':' formula { return val[1] }
                  |             { return nil }

  additional_formulae: additional_formulae ',' formula { val[0] << val[2]; return val[0] }
                     |                                 { return [] }

  additional_exprs: additional_exprs ',' expr { val[0] << val[2]; return val[0] }
                  |                           { return [] }

end

---- header

require 'adsl/parser/adsl_parser.rex'
require 'adsl/fol/first_order_logic'

module ADSL
  module Parser

---- inner

# generated by racc
  def generate_ast(str)
    scan str
    # do_parse
  end

  def parse(str)
    generate_ast(str).typecheck_and_resolve
  end

---- footer

  end
end
